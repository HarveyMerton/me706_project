/* RANGE CALIBRATION FOR IR AND ULTRASONIC SENSORS
 * Author: Peter Mitchell
 * Date: 10 MAR 2021
*/

/* SENSOR ID LIST
 * Sensor Name |  Type  | ID# | Port#
 * ----------------------------------
 *   2D120X_1  | IR Med |  1  |  ?
 *   2D120X_2  | IR Med |  2  |  ?
 *   2Y0A21_1  | IR Lng |  3  |  ?
 *   2Y0A21_2  | IR Lng |  4  |  ?
 *   ADXRS642  | GYRO   |  5  |  ?
 *   HC-SR04   | RADAR  |  6  |  ?
*/

#include <math.h>
#define TEST_NO 5

struct Sensors{
  String Name;
  String Type;
  int ID;
  String Port;
  int Ranges[TEST_NO];
  int RangesActual[TEST_NO];
};

void Calibration();
void Calibration_IR(int ID);
void Calibration_US(int ID);
void Calibration_GYRO(int ID);
void HC_SR04_range();
void generateRanges();
Sensors SensorInfo(int ID);


double cm;
double inches;
const unsigned int MAX_DIST = 23200;
const int TRIG_PIN = 9;
const int ECHO_PIN = 8;


Sensors SensorList[6] = {{"2D120X_1", "IR Medium Range", 1, "?"},
                         {"2D120X_2", "IR Medium Range", 2, "?"},
                         {"2Y0A21_1", "IR Long Range",   3, "?"},
                         {"2Y0A21_2", "IR Long Range",   4, "?"},
                         {"ADXRS642", "Gyroscope",       5, "?"},
                         {"HC-SR04",  "Ultrasonic",      6, "?"}};



void setup() {
  Serial.begin(115200);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  

  
  generateRanges();
  
      for (int i = 1; i < 6; i++){
    Serial.print("[ ");
    for (int j = 0; j < TEST_NO+1; j++){
      Serial.print(SensorList[i].Ranges[j]);
      Serial.print(" ");
    }
    Serial.println(" ]");
  }
  
    Calibration();
  
  for (int i = 1; i < 6; i++){
    Serial.print("[ ");
    for (int j = 0; j < TEST_NO+1; j++){
      Serial.print(SensorList[i].RangesActual[j]);
      Serial.print(" ");
    }
    Serial.println(" ]");
  }
  

}

void loop() {
}

void Calibration(){
    //Serial.print("Enter Sensor ID: ");
    int ID =  Serial.read();
  	ID = 1;
  	ID -= 1;
    if (ID >= 0 && ID <= 3){Calibration_IR(ID);}
    else if (ID == 4){Calibration_GYRO(ID);}
    else if (ID == 5){Calibration_US(ID);}
    else {Serial.println("ERROR: ID Not Valid.");}
}

void Calibration_IR(int ID){
  double reading = 9999;
  SensorInfo(ID);
  for (int i = 0; i < TEST_NO+1; i++){
    Serial.print("Place the Robot "); Serial.print(SensorList[ID].Ranges[i]); Serial.println("mm from a Wall.");
  	//READ VALUE Serial.analogRead(PIN);
    Serial.print("Robot Sensor Reading: "); Serial.println(5);
    SensorList[ID].RangesActual[i] = reading;
  }
}


void Calibration_US(int ID){
  SensorInfo(ID);
  HC_SR04_range();
}


void Calibration_GYRO(int ID){
  SensorInfo(ID);
}






void generateRanges(){
  int Ranges[6][2] = {{40,300},   //ID 1
                      {40,300},   //ID 2
                      {100,800},  //ID 3
                      {100,800},  //ID 4
                      {0,360},    //ID 5
                      {20,1800}}; //ID 6                  
  for (int i = 0; i < 6; i++){
    int diff = Ranges[i][1] - Ranges[i][0];
    for (int j = 0; j < TEST_NO+1; j++){
      int val = Ranges[i][0] + j*(diff/TEST_NO);
      SensorList[i].Ranges[j] = val;
    }
  }
}


Sensors SensorInfo(int ID){
  Serial.println("Sensor Info:");
  Serial.print(" Name: ");
  Serial.println(SensorList[ID].Name);
  Serial.print(" Type: ");
  Serial.println(SensorList[ID].Type);
  Serial.print(" ID: ");
  Serial.println(SensorList[ID].ID);
  Serial.print(" Port: ");
  Serial.println(SensorList[ID].Port);
  Serial.println();
  return SensorList[ID];
}



void HC_SR04_range()
{
  unsigned long t1;
  unsigned long t2;
  unsigned long pulse_width;
  float cm;
  float inches;

  // Hold the trigger pin high for at least 10 us
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // Wait for pulse on echo pin
  t1 = micros();

  while ( digitalRead(ECHO_PIN) == 0 ) {
    t2 = micros();
    pulse_width = t2 - t1;
    if ( pulse_width > (MAX_DIST + 1000)) {
      Serial.println("HC-SR04: NOT found");
      return;
    }
  }

  // Measure how long the echo pin was held high (pulse width)
  // Note: the micros() counter will overflow after ~70 min

  t1 = micros();
  while ( digitalRead(ECHO_PIN) == 1)
  {
    t2 = micros();
    pulse_width = t2 - t1;
    if ( pulse_width > (MAX_DIST + 1000) ) {
      Serial.println("HC-SR04: Out of range");
      return;
    }
  }
  
  t2 = micros();
  pulse_width = t2 - t1;

  // Calculate distance in centimeters and inches. The constants
  // are found in the datasheet, and calculated from the assumed speed
  //of sound in air at sea level (~340 m/s).
  cm = pulse_width / 58.0;
  inches = pulse_width / 148.0;

  // Print out results
  if ( pulse_width > MAX_DIST ) {
    Serial.println("HC-SR04: Out of range");
  } else {
    Serial.print("HC-SR04:");
    Serial.print(cm);
    Serial.println("cm");
  }
}




